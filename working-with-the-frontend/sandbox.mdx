---
title: "Système Sandbox"
description: "Alternative révolutionnaire à Storybook avec détection automatique et playground intégré"
icon: "play"
---

<Info>
  Notre système Sandbox révolutionne le développement de composants UI en
  remplaçant Storybook par une solution intégrée, automatique et sans
  configuration manuelle.
</Info>

## Pourquoi pas Storybook ?

<CardGroup cols={2}>
  <Card title="Problèmes Storybook" icon="x">
    Configuration manuelle pour chaque composant, fichiers .stories séparés,
    maintenance lourde
  </Card>

  <Card title="Solution Sandbox" icon="check">
    Détection automatique, zéro configuration, intégration native avec notre
    codebase
  </Card>
</CardGroup>

## Comment ça marche ?

<Steps>
  <Step title="Détection automatique">
    Un scanner analyse votre code et détecte automatiquement tous les composants avec un export `meta`
    
    ```tsx button.component.tsx
    // Ce composant sera automatiquement détecté
    export function Button() { /* ... */ }
    
    export const meta = {
      category: "UI",
      name: "Button", 
      description: "Bouton interactif avec variants"
    };
    ```
  </Step>

{" "}
<Step title="Génération automatique">
  La Sandbox génère automatiquement : - Une page de preview (`/sandbox/button`)
  - Un playground interactif avec tous les variants - La documentation basée sur
  le meta ``` /sandbox ← Liste tous les composants /sandbox/button ← Preview +
  Playground du Button /sandbox/input ← Preview + Playground de l'Input ```
</Step>

  <Step title="Playground interactif">
    Testez en temps réel tous les variants et props :
    
    ```tsx
    // Le playground génère automatiquement ces contrôles :
    variant: "default" | "primary" | "destructive"
    size: "sm" | "md" | "lg" 
    disabled: boolean
    ```
  </Step>
</Steps>

## Avantages révolutionnaires

<Tabs>
  <Tab title="Zéro maintenance">
    ```tsx
    // Avec Storybook : fichier séparé à maintenir
    // button.stories.tsx
    export default {
      title: 'UI/Button',
      component: Button,
      parameters: { /* config */ },
      argTypes: { /* types */ }
    };
    
    // Avec notre Sandbox : juste le meta dans le composant
    export const meta = {
      category: "UI",
      name: "Button",
      description: "Bouton interactif"
    };
    ```
  </Tab>

  <Tab title="Synchronisation automatique">
    ```tsx
    // Vous modifiez le composant...
    const buttonVariants = cva("base-classes", {
      variants: {
        variant: {
          default: "bg-gray-100",
          primary: "bg-blue-600",
          danger: "bg-red-600", // Nouveau variant ajouté
        }
      }
    });
    
    // La Sandbox se met à jour automatiquement !
    // Nouveau variant "danger" disponible dans le playground
    ```
  </Tab>

  <Tab title="Intégration native">
    ```tsx
    // Vos composants utilisent directement les vrais types
    interface ButtonProps extends VariantProps<typeof buttonVariants> {
      children: React.ReactNode;
    }
    
    // La Sandbox comprend automatiquement vos types TypeScript
    // Pas besoin de redéfinir les props dans un fichier séparé
    ```
  </Tab>
</Tabs>

## Fonctionnement Technique

### Le Scanner : Le Cerveau du Système

<Warning>
  **Pourquoi le meta est OBLIGATOIRE** : Sans export meta, le scanner ne peut
  pas détecter votre composant. C'est le "contrat" qui permet à la Sandbox de
  comprendre votre composant.
</Warning>

Le scanner fonctionne comme un détective qui analyse votre code :

<Steps>
  <Step title="Analyse des fichiers">
    Le scanner parcourt `/components/common/` et cherche les fichiers `.tsx`
    
    ```typescript scanner.ts
    // Le scanner lit chaque fichier et cherche cette signature :
    export const meta = {
      category: string,    // OBLIGATOIRE pour catégoriser
      name: string,        // OBLIGATOIRE pour identifier
      description: string, // OBLIGATOIRE pour documenter
    };
    ```
  </Step>

  <Step title="Extraction des métadonnées">
    Pour chaque composant trouvé, le scanner extrait :
    
    ```typescript
    // Ce que le scanner "voit" dans votre composant :
    {
      componentName: "Button",           // Nom de la fonction export
      filePath: "components/common/button/button.component.tsx",
      meta: {
        category: "UI",
        name: "Button",
        description: "Bouton interactif avec variants"
      },
      variants: buttonVariants,          // Configuration CVA
      hasProps: true,                    // Si interface Props existe
      hasChildren: false                 // Si accepte children
    }
    ```
  </Step>

  <Step title="Génération des routes">
    Le scanner génère automatiquement les routes Next.js :
    
    ```
    /sandbox                    ← Page index avec liste des composants
    /sandbox/button            ← Page dédiée au Button
    /sandbox/input             ← Page dédiée à l'Input
    /sandbox/dialog            ← Page dédiée au Dialog
    ```
  </Step>
</Steps>

### Configuration du Scanner

```json scanner-config.json
{
  "scanDirectory": "components/common", // Où chercher les composants
  "filePatterns": [".tsx"], // Types de fichiers à analyser
  "metaExportName": "meta", // Nom de l'export à chercher
  "componentExportPattern": "export function", // Pattern des composants
  "excludeDirectories": ["node_modules", ".git"], // Dossiers à ignorer
  "cacheTimeout": 1000 // Cache pour les performances
}
```

## Le Playground Automatique

<Tabs>
  <Tab title="Génération des contrôles">
    ```tsx
    // Votre composant avec CVA :
    const buttonVariants = cva("base", {
      variants: {
        variant: { default: "...", primary: "..." },
        size: { sm: "...", md: "...", lg: "..." }
      }
    });
    
    // La Sandbox génère automatiquement :
    <select name="variant">
      <option value="default">default</option>
      <option value="primary">primary</option>
    </select>
    
    <select name="size">
      <option value="sm">sm</option>
      <option value="md">md</option>
      <option value="lg">lg</option>
    </select>
    ```
  </Tab>

{" "}
<Tab title="Preview en temps réel">
  ```tsx // Quand vous changez un contrôle dans le playground : const
  [selectedVariant, setSelectedVariant] = useState("default"); const
  [selectedSize, setSelectedSize] = useState("md"); // La preview se met à jour
  instantanément :
  <Button variant={selectedVariant} size={selectedSize}>
    Exemple de bouton
  </Button>
  ```
</Tab>

  <Tab title="Code généré">
    ```tsx
    // La Sandbox affiche le code correspondant :
    <Button variant="primary" size="lg" disabled={false}>
      Exemple de bouton
    </Button>
    
    // Que vous pouvez copier-coller directement !
    ```
  </Tab>
</Tabs>

## Navigation et Organisation

<CardGroup cols={3}>
  <Card title="Page Index" icon="list">
    `/sandbox` - Vue d'ensemble de tous les composants organisés par catégorie
  </Card>

  <Card title="Page Composant" icon="eye">
    `/sandbox/[nom]` - Preview et playground interactif pour un composant
  </Card>

  <Card title="Recherche" icon="search">
    Filtrage par catégorie, nom ou tags pour trouver rapidement un composant
  </Card>
</CardGroup>

## Exemple Concret : Découvrir la Sandbox

<Steps>
  <Step title="Vous arrivez sur /sandbox">
    Vous voyez une interface claire avec tous vos composants organisés :
    
    ```
    UI Components
      Button - Bouton interactif avec variants
      Input - Champ de saisie avec validation
      Dialog - Fenêtre modale réutilisable
    
    Layout Components  
      Card - Conteneur avec bordure et ombre
      DataTable - Tableau avec tri et pagination
    ```
  </Step>

{" "}
<Step title="Vous cliquez sur 'Button'">
  Vous arrivez sur `/sandbox/button` et découvrez : **À gauche** : Le playground
  interactif ``` Variant: [default ▼] [primary] [destructive] Size: [sm] [md ▼]
  [lg] Disabled: ☐ Children: [Cliquez-moi ___________] ``` **À droite** : La
  preview en temps réel ```tsx
  <Button variant="default" size="md">
    Cliquez-moi
  </Button>
  ```
</Step>

  <Step title="Vous testez les variants">
    Vous changez `variant` à `primary` → La preview se met à jour instantanément !
    
    **Code généré automatiquement** :
    ```tsx
    <Button variant="primary" size="md">
      Cliquez-moi  
    </Button>
    ```
    
    **Bouton "Copy Code"** → Vous collez directement dans votre composant !
  </Step>
</Steps>

<Tip>
  **Magic !** Aucune configuration, aucun fichier story à écrire. Juste votre
  composant avec son export meta et tout fonctionne automatiquement.
</Tip>

## Avantages vs Storybook

<Tabs>
  <Tab title="Maintenance">
    ```tsx
    // Storybook : 2 fichiers à maintenir
    // button.component.tsx
    export function Button() { /* composant */ }
    
    // button.stories.tsx  
    export default { /* config storybook */ };
    export const Default = { /* story */ };
    export const Primary = { /* story */ };
    
    // Sandbox : 1 seul fichier
    // button.component.tsx
    export function Button() { /* composant */ }
    export const meta = { /* config sandbox */ };
    ```
  </Tab>

  <Tab title="Synchronisation">
    ```tsx
    // Avec Storybook : si vous ajoutez un variant...
    const buttonVariants = cva("base", {
      variants: {
        variant: { 
          default: "...", 
          primary: "...",
          danger: "..." // Nouveau variant
        }
      }
    });
    
    // Vous devez MANUELLEMENT ajouter une story
    export const Danger = { args: { variant: "danger" } };
    
    // Avec Sandbox : automatiquement disponible !
    // Aucune action requise, le playground se met à jour
    ```
  </Tab>
</Tabs>

## Cache et Performance

- **Cache automatique** : 1 seconde
- **Invalidation** : Changement de configuration
- **Force refresh** : Redémarrer le dev server

<Note>
  La Sandbox transforme complètement l'expérience de développement des
  composants UI en éliminant toute la friction de Storybook tout en offrant plus
  de fonctionnalités.
</Note>{" "}
