---
title: Gestion d'√©tat
description: "TypeScript et gestion d'√©tat hybride pour une architecture type-safe"
icon: database
---

<Info>
  Notre architecture repose sur un backend client type-safe avec DTOs partag√©s,
  combin√© √† une gestion d'√©tat hybride claire entre donn√©es serveur et √©tat
  client.
</Info>

## Vue d'ensemble

La gestion d'√©tat suit une architecture en trois couches compl√©mentaires :

<CardGroup cols={3}>
  <Card title="Backend Client" icon="code" href="#backend-client-typescript">
    Type safety compl√®te avec DTOs partag√©s entre frontend et backend
  </Card>

<Card title="TanStack Query" icon="server" href="#tanstack-query">
  Cache intelligent et synchronisation automatique des donn√©es serveur
</Card>

  <Card title="Zustand" icon="desktop" href="#zustand">
    √âtat local pour l'interface utilisateur et les pr√©f√©rences
  </Card>
</CardGroup>

<Warning>
  **Principe fondamental** : Toutes les donn√©es proviennent du backend client.
  Aucun appel direct √† l'API.
</Warning>

## Backend Client

### Configuration et utilisation

Le `ChataigneClient` est import√© depuis le package `@chataigne/client` et instanci√© dans chaque service avec l'authentification :

<CodeGroup>

```typescript
import { ChataigneClient } from "@chataigne/client";
import { authClient } from "@/lib/auth-client";

// Instance locale dans chaque service
const client = new ChataigneClient(authClient.$fetch);
```

</CodeGroup>

### Utilisation dans les services

<Tip>
  Les services orchestrent les appels au backend client et convertissent les
  donn√©es si n√©cessaire.
</Tip>

<CodeGroup>

```typescript catalog.service.ts
import { ChataigneClient, CreateCatalogDTO } from "@chataigne/client";
import { authClient } from "@/lib/auth-client";

const client = new ChataigneClient(authClient.$fetch);

export const createCatalog = async (data: CreateCatalogDTO) => {
  return client.location.catalog.create(data);
};

export const getLocationCatalogs = async (locationId: string) => {
  return client.location.getLocationCatalogs(locationId);
};
```

</CodeGroup>

### Avantages cl√©s

<AccordionGroup>

<Accordion title="Type Safety compl√®te">
Les DTOs sont partag√©s entre frontend et backend. Toute modification du contrat API provoque une erreur de compilation.

```typescript
// ‚úÖ TypeScript v√©rifie automatiquement les types
const catalog = await client.location.catalog.create({
  name: "Menu √ât√©",
  locationId: "loc-123",
});

// ‚úÖ Autocompl√©tion et validation des propri√©t√©s
const catalogs = await client.location.getLocationCatalogs("loc-123");
```

</Accordion>

<Accordion title="API coh√©rente et pr√©visible">
Structure uniforme pour tous les appels :

```typescript
// Pattern coh√©rent pour toutes les ressources
client.location.catalog.create(data);
client.location.catalog.update(catalogId, name);
client.location.catalog.delete(catalogId);
client.location.getLocationCatalogs(locationId);
```

</Accordion>

<Accordion title="Gestion d'erreurs centralis√©e">
Toutes les erreurs passent par le m√™me m√©canisme, facilitant le debugging et la gestion globale :

```typescript
// Gestion des erreurs automatique et coh√©rente
const catalogs = await client.location.getLocationCatalogs(locationId);
return catalogs;
```

</Accordion>

</AccordionGroup>

## TanStack Query

<Info>
  TanStack Query r√©sout les d√©fis du cache et de la synchronisation des donn√©es
  serveur. Il √©vite les appels API redondants, garde nos donn√©es fra√Æches
  automatiquement, et g√®re les √©tats de chargement/erreur pour nous.
</Info>

<Note>
  TanStack Query g√®re le cache et la synchronisation de toutes les donn√©es
  provenant du backend client.
</Note>

### Configuration

<Steps>
  <Step title="Configuration du QueryClient">
    Configuration simple pour d√©marrer :

    ```typescript
    // config/query.config.ts
    import { QueryClient } from "@tanstack/react-query";

    export const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          staleTime: 5 * 60 * 1000, // 5 minutes
          retry: 3,
        },
      },
    });
    ```

  </Step>

  <Step title="Provider dans l'application">
    Int√©gration dans l'application :

    ```typescript
    // app/providers.tsx
    export function Providers({ children }: { children: React.ReactNode }) {
      return (
        <QueryClientProvider client={queryClient}>
          {children}
        </QueryClientProvider>
      );
    }
    ```

  </Step>
</Steps>

### Patterns de hooks

<Tabs>
  <Tab title="Lecture de donn√©es">
    Les custom hooks encapsulent la logique TanStack Query et fournissent une interface simple pour nos composants. Ils transforment nos services en hooks r√©actifs avec cache automatique.

    Pattern pour r√©cup√©rer des donn√©es via le backend client :

         ```typescript use-catalogs.hook.ts
     import { useQuery } from "@tanstack/react-query";
     import { getLocationCatalogs } from "../services/catalog.service";

     export function useCatalogs(locationId: string) {
       return useQuery({
         queryKey: ["catalogs", locationId],
         queryFn: () => getLocationCatalogs(locationId),
       });
     }
     ```

  </Tab>

  <Tab title="Modification de donn√©es">
    Les mutations g√®rent les op√©rations de cr√©ation, modification et suppression. Elles invalident automatiquement le cache pour maintenir la coh√©rence des donn√©es.

    Pattern pour les mutations avec invalidation du cache :

              ```typescript
     export function useCreateCatalog() {
       const queryClient = useQueryClient();

       return useMutation({
         mutationFn: createCatalog,
         onSuccess: () => {
           queryClient.invalidateQueries({ queryKey: ["catalogs"] });
         },
       });
     }
     ```

  </Tab>
</Tabs>

### Utilisation dans les composants

Nos composants consomment les hooks de donn√©es sans conna√Ætre les d√©tails de TanStack Query. Ils re√ßoivent des donn√©es typ√©es, des √©tats de chargement et b√©n√©ficient automatiquement du cache.

Exemple d'int√©gration simple :

<CodeGroup>

```tsx CatalogList.component.tsx
export function CatalogList({ locationId }: { locationId: string }) {
  const { data: catalogs, isLoading } = useCatalogs(locationId);

  if (isLoading) return <CatalogListSkeleton />;

  return (
    <div className="space-y-4">
      {catalogs?.map((catalog) => (
        <CatalogCard key={catalog.id} catalog={catalog} />
      ))}
    </div>
  );
}
```

</CodeGroup>

## Zustand

<Info>
  Zustand g√®re l'√©tat client qui ne vient pas du serveur : pr√©f√©rences
  utilisateur, √©tat des interfaces (sidebar ouverte/ferm√©e), filtres temporaires
  et donn√©es de formulaires en cours de saisie.
</Info>

<Note>
  Zustand ne doit **jamais** dupliquer des donn√©es serveur. Son r√¥le est
  compl√©mentaire √† TanStack Query.
</Note>

### Store par feature

On cr√©e un store Zustand par feature pour isoler son √©tat UI. Cela √©vite les conflits entre features et facilite la maintenance.

Pattern pour l'√©tat UI d'une feature :

<CodeGroup>

```typescript features/catalog/store/catalog.store.ts
import { create } from "zustand";
import { CatalogDTO, ProductDTO } from "@chataigne/client";

interface CatalogState {
  catalog: CatalogDTO | null;
  selectedCatalogId: string | null;

  // Actions
  setCatalog: (catalog: CatalogDTO) => void;
  setSelectedCatalogId: (id: string | null) => void;
  updateProduct: (updatedProduct: ProductDTO) => void;
  addProduct: (newProduct: ProductDTO) => void;
}

export const useCatalogStore = create<CatalogState>()((set, get) => ({
  catalog: null,
  selectedCatalogId: null,

  setCatalog: (catalog) => set({ catalog }),
  setSelectedCatalogId: (id) => set({ selectedCatalogId: id }),

  updateProduct: (updatedProduct) =>
    set((state) => ({
      catalog: state.catalog
        ? {
            ...state.catalog,
            products: [
              ...state.catalog.products.filter(
                (p) => p.id !== updatedProduct.id
              ),
              updatedProduct,
            ],
          }
        : null,
    })),

  addProduct: (newProduct) =>
    set((state) => ({
      catalog: state.catalog
        ? {
            ...state.catalog,
            products: [...state.catalog.products, newProduct],
          }
        : null,
    })),
}));
```

</CodeGroup>

### Store global

Le store global contient les pr√©f√©rences qui affectent toute l'application : th√®me, langue, param√®tres utilisateur. On utilise la persistance pour conserver ces donn√©es entre les sessions.

Pour l'√©tat vraiment global de l'application :

<CodeGroup>

```typescript shared/store/app.store.ts
import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";

interface AppState {
  theme: "light" | "dark";

  // Actions
  toggleTheme: () => void;
}

export const useAppStore = create<AppState>()(
  persist(
    (set) => ({
      theme: "light",

      toggleTheme: () =>
        set((state) => ({
          theme: state.theme === "light" ? "dark" : "light",
        })),
    }),
    {
      name: "app-storage",
      storage: createJSONStorage(() => localStorage),
    }
  )
);
```

</CodeGroup>

## Int√©gration compl√®te

Voici comment on fait collaborer les trois couches dans un composant r√©el. Les donn√©es serveur viennent de TanStack Query, l'√©tat UI de Zustand, et la logique m√©tier combine les deux.

Exemple d'un composant utilisant les trois couches de l'architecture :

<CodeGroup>

```tsx CatalogDashboard.component.tsx
export function CatalogDashboard({ locationId }: { locationId: string }) {
  // üìä Donn√©es serveur via TanStack Query + Backend Client
  const { data: catalogs } = useCatalogs(locationId);

  // üé® √âtat client via Zustand
  const { selectedCatalogId, setSelectedCatalogId } = useCatalogStore();

  // üîÑ Logique d√©riv√©e
  const selectedCatalog = catalogs?.find(
    (catalog) => catalog.id === selectedCatalogId
  );

  return (
    <div className="space-y-6">
      <select onChange={(e) => setSelectedCatalogId(e.target.value)}>
        {catalogs?.map((catalog) => (
          <option key={catalog.id} value={catalog.id}>
            {catalog.name}
          </option>
        ))}
      </select>

      {selectedCatalog && <CatalogDetails catalog={selectedCatalog} />}
    </div>
  );
}
```

</CodeGroup>

## Bonnes pratiques

<Steps>
  <Step title="Backend Client">
    ‚Ä¢ Toujours passer par le backend client pour les appels API

    ‚Ä¢ Ne jamais faire d'appels directs aux endpoints

    ‚Ä¢ Utiliser les types partag√©s pour la type safety

    ‚Ä¢ Centraliser la gestion des erreurs

  </Step>

  <Step title="TanStack Query">
    ‚Ä¢ Utiliser exclusivement pour les donn√©es serveur

    ‚Ä¢ Structurer les query keys de mani√®re coh√©rente

    ‚Ä¢ Invalider le cache apr√®s les mutations

    ‚Ä¢ G√©rer les √©tats de loading et d'erreur

  </Step>

  <Step title="Zustand">
    ‚Ä¢ R√©server √† l'√©tat UI local uniquement

    ‚Ä¢ Ne jamais dupliquer les donn√©es serveur

    ‚Ä¢ Cr√©er un store par feature pour l'isolation

    ‚Ä¢ Utiliser la persistance pour les pr√©f√©rences globales

  </Step>

  <Step title="Query Keys">
    ‚Ä¢ Structure hi√©rarchique : `["resource", id, "subresource"]`

    ‚Ä¢ Coh√©rence dans toute l'application

    ‚Ä¢ √âviter les cl√©s trop g√©n√©riques

    ‚Ä¢ Faciliter l'invalidation cibl√©e

  </Step>
</Steps>
